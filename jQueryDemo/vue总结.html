1. computed: {} 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。
2. 用 key 管理可复用的元素 (如果两个模版使用了相同的元素: 内容则不变)
3. v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
4. v-show
就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

5.vuex的应用
	采用一个简单的 store 模式管理各种状态：
	let store = new Vuex.Store({
    state: {}，
    getters: {}，
    mutations: {}，
    actions: {}，
    modules：{}
	});

	state: 驱动应用的数据源；
	getters: 可以认为是 store 的计算属性；
	mutations: 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation；
	actions: 响应在view上的用户输入导致的状态变化, Action 提交的是 mutation, 而不是直接变更状态, 可以包含任意异步操作。
	modules: 将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割。
