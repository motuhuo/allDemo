1. computed: {} 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。
2. 用 key 管理可复用的元素 (如果两个模版使用了相同的元素: 内容则不变)
3. v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
4. v-show
就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

5.vuex的应用
	采用一个简单的 store 模式管理各种状态：
	let store = new Vuex.Store({
    state: {}，
    getters: {}，
    mutations: {}，
    actions: {}，
    modules：{}
	});

	state: 驱动应用的数据源；
	getters: 可以认为是 store 的计算属性；
	mutations: 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation； (方法)
	actions: 响应在view上的用户输入导致的状态变化, Action 提交的是 mutation, 而不是直接变更状态, 可以包含任意异步操作。（执行方法）
	modules: 将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割。

6.一个vue对象通常包括的几个属性
	//从父组件获取数据
	props: {
		name: {
  		type: Object
  	}
	}

	//vue对象的数据
	data () {
    return {
      msg: 'msg'
    }
  }

  //vue对象的方法
	methods: {}

	//计算逻辑放到computed中 
	computed: {}

	//属性已绑定，dom未生成，一般在这里进行ajax处理以及页面初始化处理
	created () {
		this.$http.get('/api/goods').then(( response ) => {
      response = response.body;
    })
	}
	
	//组件的组成部分
	components: {}

	//过滤器
	filters: {}

	//完成挂载
	mounted () {}

	//更新 
	this.$nextTick (() => {})
	
  8、生命周期
  
  beforeCreate 组件实例刚被创建，组件属性计算之前，如data属性等
	
	created: 组件实例创建完成，属性已绑定，data初始化， 但DOM还末生成，$el属性还不存在

	beforeMount： 模板编译/挂载之前  data,el初始化

	mounted: 模板编译/挂载之后  发起请求，拿数据，路由跳转

	beforeUpdata: 组件更新之前

	updated: 组件更新之后 

	activated: 组件被激活时调用

	beforeDestory: 组件销毁之前调用
	


	//过渡效果
	1. v-enter: 定义进入过渡的开始状态。在元素被插入时生效，在下一个帧移除。

	2.v-enter-active: 定义过渡的状态。在元素整个过渡过程中作用，在元素被插入时生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。

	 3.v-enter-to 定义进入过渡的结束状态。在元素被插入一帧后生效（于此同时 v-enter 被删除），在 transition/animation 完成之后移除。

	 4.v-leave 定义离开过渡的开始状态。在离开过渡被触发时生效，在下一个帧移除。

	 5.v-leave-active 定义过渡的状态。在元素整个过渡过程中作用，在离开过渡被触发后立即生效，在 transition/animation 完成之后移除。这个类可以被用来定义过渡的过程时间，延迟和曲线函数。

	 6.v-leave-to 定义离开过渡的结束状态。在离开过渡被触发一帧后生效（于此同时 v-leave 被删除），在 transition/animation 完成之后移除。

	<!-- .fade-enter-active, .fade-leave-active {
    transition: opacity .5s
  }
  .fade-enter, .fade-leave-to {
    opacity: 0
  } -->

  this.$http.get('/api/seller').then((response) => {
    response = response.body;
    if (response.errno === ERR_Ok){
      this.seller = response.data;
    }
  })