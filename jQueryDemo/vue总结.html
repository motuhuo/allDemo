1. computed: {} 计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。
2. 用 key 管理可复用的元素 (如果两个模版使用了相同的元素: 内容则不变)
3. v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。
4. v-show
就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。

5.vuex的应用
	采用一个简单的 store 模式管理各种状态：
	let store = new Vuex.Store({
    state: {}，
    getters: {}，
    mutations: {}，
    actions: {}，
    modules：{}
	});

	state: 驱动应用的数据源；
	getters: 可以认为是 store 的计算属性；
	mutations: 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation； (方法)
	actions: 响应在view上的用户输入导致的状态变化, Action 提交的是 mutation, 而不是直接变更状态, 可以包含任意异步操作。（执行方法）
	modules: 将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割。

6.一个vue对象通常包括的几个属性
	//从父组件获取数据
	props: {
		name: {
  		type: Object
  	}
	}

	//vue对象的数据
	data () {
    return {
      msg: 'msg'
    }
  }

  //vue对象的方法
	methods: {}

	//计算逻辑放到computed中 
	computed: {}

	//属性已绑定，dom未生成，一般在这里进行ajax处理以及页面初始化处理
	created () {
		this.$http.get('/api/goods').then(( response ) => {
      response = response.body;
    })
	}
	
	//组件的组成部分
	components: {}

	//过滤器
	filters: {}

	//完成挂载
	mounted () {}

	//更新 
	this.$nextTick (() => {})
	